### 9.4 页面置换
---
- 背景：若一个页错误发生，却发现空闲帧列表上并没有空闲帧，即所有内存都在使用

- 解决方法：**页置换**

- 用户并不关心其进程是否运行在调页系统上：调页对用户而言应是透明的
---
#### 9.4.1 基本页置换

- **带页置换的页错误处理算法**
    1. 查找所需页在磁盘上的位置
    2. 查找一个空闲帧
        1. 如果有空闲帧，就使用它
        2. 如果没有空闲帧，使用页置换算法选择一个“牺牲”帧(victim frame)
        3. 将“牺牲”帧的内容写到磁盘上，改变页表和帧表
    3. 将所需页读入空闲帧，改变页表和帧表
    4. 重启用户进程

- 使用脏位以降低额外I/O开销
    - 问题：如果没有空闲帧，那么需要采用两个页传输(一个换入，一个换出)
    - 思路：如果要换出的页并没有更改过，就不需要换出。直接清零即可
    - 实现
        - 每页有一个脏位，每当页内的任何字或字节被写入，就会设置脏位表示该页已修改
        - 如果某页被选择为替换页，首先检查其脏位
        - 如果此页修改过，就需要将其换出
        - 如果此页未修改过，直接放入空闲帧表即可

- 为了实现按需调页，必须开发帧分配算法和页置换算法
    - 帧分配算法：如果内存中有许多进程，必须决定为每个进程各分配多少帧
    - 页置换算法：当需要页置换时，必须选择要置换的帧

- 评估页置换算法
    - 需要数据
        - 引用串：内存的引用序列
        - 可用帧的数量
    - 然后使用待评估的页置换算法计算发生页错误的次数

---
#### 9.4.2 FIFO页置换

- 思路
    - 使用一个FIFO队列管理内存中的所有页
    - 当必须置换一页时，选择最旧的一页

- 优点：易于理解和实现

- 缺点：性能差

- **Belady 异常**：对有的页置换算法，页错误率可能会随着可用帧的数量的增加而增加

---
#### 9.4.3 最优置换

- 思路：置换最长时间不会使用的页

- 优点
    - 最优页置换算法是所有算法中产生页错误率最低
    - 绝没有Belady异常

- 缺点
    - 难以实现，因为需要引用串的未来知识

- 主要用于比较研究
---
#### 9.4.4 LRU页置换

- 思路
    - 使用离过去最近作为不远将来的近似
    - 为每个页关联该页上次使用的时间
    - 当必须置换一页时，置换最长时间没有使用的页

- 如何为每一页关联该页上次使用的时间
    - 可以使用计数器或栈来实现
    - 计数器
        - 为每个页表项关联一个使用时间域，并为CPU增加一个计数器
        - 对每次内存引用，计数器都会增加
        - 对每次内存引用，时钟寄存器的内容会被复制到相应页所对应页表项的使用时间域内
    - 栈
        - 每当引用一个页，该页就从栈中删除并放到顶部
        - 栈顶部总是最近使用页，而栈底部总是LRU页
- 优点
    - 性能好
    - 不产生Belady异常
- 缺点
    - 需要一定的硬件支持
---
#### 9.4.5 近似LRU页置换

0. 引用位
    - 每当引用一个页时，相应页表的引用位就被硬件置位

1. 附加引用位算法
    - 思路
        - 为位于内存内的每个表中的页保留一个8位的字节
        - 这些8位移位寄存器包含着该页在最近8个时间周期内的使用情况
        - 在规定时间间隔内，时钟定位器产生中断并将控制权转交给操作系统
        - 操作系统把每个页的引用位转移到其8位字节的高位，将其他位向右移一位，并抛弃最低位
        - 具有最小值的页为LRU页，可以被置换

2. 二次机会算法
    - 思路
        - 二次机会置换的基本算法是FIFO置换算法
        - 当要选择一个页时，检查其引用位
        - 如果值为0，则直接置换该页
        - 如果值为1，那么给该页第二次机会，并选择下一个FIFO页
        - 当一个页获得第二次机会，其引用位清零，并被放到FIFO队尾

    - 实现：使用循环队列，具体略

3. 增强型二次机会算法
    - 思路
        - 基本算法是FIFO置换算法
        - 需要使用引用位和脏位作为有序对 `(x,y)`
        - 将所有页分为4个等级
            1. `(0,0)`：最近没有使用且没有修改，用于置换的最佳页
            2. `(0,1)`：最近没有使用但修改过，不好的选择，因为需要换出页，需要额外I/O
            3. `(1,0)`：最近使用过但没修改过
            4. `(1,1)`：最近使用过且修改过，用于置换的最差选择
        - 当必须置换一页时，从等级最低的页的集合中，按照FIFO算法挑选一页

    - 优点：比简单的二次机会算法具有更少的I/O数量
---
#### 9.4.6 基于计数的页置换
    
- 计数器：为每个页保留一个用于记录其引用次数的计数器

- 最不经常使用页置换算法(least frequently used,LFU)
    - 思路：要求置换计数最小的页
    - 理由：活动页应该有更大的引用次数
    - 问题：一个页在进程开始时使用很多，以后不再使用，它有较大的次数，但不应该在内存中
    - 解决：定期地将次数计数器右移一位，已形成指数衰减的平均使用次数

- 最经常使用页置换算法(most frequently used,MFU)
    - 思路：要求置换计数最大的页
    - 理由：具有最小次数的页可能刚刚调进来，且还没有使用

- 这两种算法都很费时，且不能很好的近似最优置换算法

---
#### 9.4.7 页缓冲算法

- 基于缓冲池的进程快速重启方法
    - 当发生页错误时，会像以前一样选择一个牺牲帧
    - 在牺牲帧写出之前，所需要的页就从缓冲池中读到空闲内存
    - 这种方法允许进程快速重启，而无需等待牺牲帧页的写出
    - 当在牺牲帧以后写出时，它再加入到空闲帧池

- 空闲时写入修改页方法
    - 维护一个已修改的列表
    - 每当调页设备空闲时，就选择一个修改页并写到磁盘上，接着重新设置其修改位
    - 增加了当需要选择置换时干净页的概率而不必写出

- 通过在空闲帧池中保留页信息来减少I/O
    - 保留一个空闲帧池
    - 记住哪些页在哪些帧中
    - 如果在该帧被重用之前需要使用原来页，原来页可以直接从空闲帧池中取出
    - 这样就避免了一次I/O
---
#### 9.4.8 应用程序与页置换
- 有些情况下，应用程序通过操作系统虚拟内存来访问数据会比操作系统不提供任何缓冲区更坏
- 比如：数据库，它可自己提供内存管理和I/O缓冲，操作系统没必要多此一举的再提供一遍
- 这类程序比提供通用算法的操作系统更能理解自己的内存使用和磁盘使用
- 生磁盘（raw disk）：有的操作系统允许特殊程序将磁盘当作逻辑块数组使用，而不需要通过文件系统的数据结构，这种数组称为生磁盘
- 生I/O：对生磁盘的I/O，可以绕过所有文件系统服务
---
&copy; 2018 T0UGH. All rights reserved.