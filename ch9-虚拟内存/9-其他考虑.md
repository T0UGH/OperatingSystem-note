### 9.9 其他考虑
---
#### 9.9.1 预调页

- 使用纯按需调页系统，当一个进程开始时会出现大量页错误

- 这种情况是由于试图将最初局部调入到内存的结果

- 预调页试图阻止这种大量的初始调页

- 可以通过同时将所有所需要的页一起调入到内存中来实现

- 例如：
    - 如果必须暂停一个进程，那么要记住该进程的工作集合
    - 当该进程需要重启时，在重启进程前会自动调入位于其工作集合内的所有页

---
#### 9.9.2 页大小

- 页面大小总为2的幂

- 如何选择页大小
    - 要考虑页表大小
        - 对于给定虚拟内存空间，降低页大小增加了页的数量，因此也增加了页表大小
        - 因为每个活动进程必须有其自己的页表，所以较大的页是比较理想的
    - 较小的页可更好地利用内存
        - 最后页的一部分并未使用，而形成内部碎片
        - 平均来说，每个进程的最后页的
    - 页读写所需要的时间
        - 因寻道和延迟时间远远超过传输时间，所以为了最小化I/O时间，需要较大的页
    - 局部模型的考虑
        - 采用较小的页，局部性可以获得更好的精度
---
#### 9.9.3 TLB 范围

- **TLB命中率**：通过TLB而不是页表所进行的虚拟地址转换的百分比

- 用于构造TLB的相关内存既昂贵又费电

- **TLB范围**：TLB范围指通过TLB可访问的内存量，并且等于TLB条数与页大小之积

- 增加TLB范围的另一种方法是增加页的大小或提供多种页大小

- 用软件而不是硬件来管理TLB会影响性能
---
#### 9.9.4 反向页表

- 反向页表：通过创建一个表，该表为每个物理页包含一个条目，可根据`<processId , page-number>`进行检索

- 外部页表
    - 反向页表不包括进程 **逻辑地址空间** 的完整信息
    - 出现页错误时，需要这些信息
    - 所以每个进程需要保留一个外部页表
    - 每个这样的表看起来如同传统的进程页表
---
#### 9.9.5 程序结构

- 对于用户程序，请求页面调度被设计为透明的

- 数据结构和程序结构的仔细选择能增加局部性，并降低错误率和工作集合内的页数

- 代码和数据的分离和重入代码的生成意味着代码只能读不能写

- C和C++经常使用指针，降低了进程的局部性

- 面向对象程序的引用局部性也较差
---
#### 9.9.6 I/O 互锁

- 在使用请求页面调度时，有时需要允许有些页在内存中被锁住，这种情况之一是需要对用户的虚拟内存进行 I/O

- 必须确保按下面顺序的事件不会发生
    1. 一个进程发出一个I/O请求，并被加入到I/O设备的等待队列上，同时CPU被交给了其他进程
    2. 这些进程引起页错误，置换了等待进程用于I/O的缓存页
    3. 当I/O请求移到设备队列的头部时，就针对指定地址进行I/O
    4. 这时该帧已被属于另一个进程的不同页所使用

- 两种解决方案
    1. 绝不允许用户内存进行I/O
        - I/O只能发生在系统内存和I/O设备之间，数据在系统内存和用户内存之间复制
    2. 允许页锁在内存中
        - 每个帧都有一个锁住位，如果一个帧被锁住，那么它不能被置换
---
&copy; 2018 T0UGH. All rights reserved.